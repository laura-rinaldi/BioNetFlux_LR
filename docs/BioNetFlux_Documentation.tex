\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}
\usepackage{hyperref}
\usepackage{tocloft}
\usepackage{titlesec}
\usepackage{float}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{tikz}
\usepackage{bclogo}
\usepackage{xcolor}
\usepackage{tcolorbox}
\usepackage{enumitem}

% Define a custom TODO box
\newtcolorbox{todobox}{
	colback=yellow!10!white,
	colframe=orange!70!black,
	title=\textbf{TODO},
	fonttitle=\bfseries,
	coltitle=white,
	boxrule=0.8pt,
	arc=4pt,
	left=6pt,
	right=6pt,
	top=6pt,
	bottom=6pt
}

\newtcolorbox{warningbox}{
	colback=red!5!white,
	colframe=red!75!black,
	title=\textbf{WARNING!},
	fonttitle=\bfseries,
	coltitle=white,
	boxrule=1pt,
	arc=4pt,
	left=6pt,
	right=6pt,
	top=6pt,
	bottom=6pt
}


% Define a custom box for deprecated notices
\newtcolorbox{deprecatedbox}{
	colback=red!5!white,
	colframe=red!75!black,
	title=DEPRECATED,
	fonttitle=\bfseries,
	boxrule=0.8pt,
	arc=4pt,
	left=1mm,
	right=1mm,
	top=1mm,
	bottom=1mm
}


% Define a custom box for deprecated notices
\newtcolorbox{structurebox}{
	colback=teal!5!white,
	colframe=teal!75!black,
	title=DATA STRUCTURE,
	fonttitle=\bfseries,
	boxrule=0.8pt,
	arc=4pt,
	left=1mm,
	right=1mm,
	top=1mm,
	bottom=1mm
}



\newtcolorbox{notebox}{
	colback=olive!5!white,
	colframe=olive!75!black,
	title=NOTE,
	fonttitle=\bfseries,
	boxrule=0.8pt,
	arc=4pt,
	left=1mm,
	right=1mm,
	top=1mm,
	bottom=1mm
}

	

% Page setup
\geometry{margin=2.5cm}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\textsc{BioNetFlux Documentation}}
\fancyhead[R]{\thepage}
\fancyfoot[C]{\textit{Multi-Domain Biological Network Flow Simulation}}

% Hyperlink setup
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={BioNetFlux Documentation},
    pdfauthor={BioNetFlux Development Team},
}

% Code listing setup
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

% Custom commands
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\bionetflux}{\textsc{BioNetFlux}}

\newcommand{\brokencode}{\bcattention}

% Title page customization
\title{\Huge {\textbf{\bionetflux{} Documentation}} \\[0.5cm]
       \Large Multi-Domain Biological Network Flow Simulation}
\author{BioNetFlux Development Team}
\date{\today}

\begin{document}

% Title page
\begin{titlepage}
    \centering
    
    % BioNetFlux Logo
    \includegraphics[width=0.6\textwidth]{BioNetFlux_Logo.jpg}\\[1cm]
    
    {\Huge \textbf{\bionetflux{}} \\[0.5cm]}
    {\Large \textbf{Documentation} \\[1cm]}
    
    {\large Multi-Domain Biological Network Flow Simulation \\[0.5cm]}
    {\large A Python Framework for Complex Network Geometries \\[2cm]}

    
    {\Large BioNetFlux Development Team \\[0.5cm]}
    {\large \today}
    
    \vfill
    
    {\footnotesize 
    \textit{Comprehensive guide to multi-domain biological transport simulations} \\
    \textit{including Keller-Segel chemotaxis and organ-on-chip modeling}
    }
        
        \vskip3cm
        
    % Barra bar
    \includegraphics[width=\textwidth]{Barra_D34Health.png}\\[2cm]
\end{titlepage}

% Table of contents
\tableofcontents

\clearpage

\section*{Acknowledgements}
\addcontentsline{toc}{section}{Acknowledgements}

The development of BioNetFlux was carried out thanks to the support by the Italian Ministry of Research, under the complementary actions to the NRRP ``D34Health - Digital Driven Diagnostics, prognostics and therapeutics for sustainable Health care" Grant (\#PNC0000001).

\

Portions of this documentation were drafted with assistance from the Claude Sonnet 4 AI language model, with all content reviewed and edited by the authors.

\

AI tools were used as programming and writing aids only. All mathematical derivations,
algorithmic design, and numerical validation were performed by the authors.
\clearpage

\section{Introduction}

\bionetflux{} is a computational framework designed for simulating biological transport phenomena on complex one dimensional networks. Based on an Hybridized Discontinuous Galerkin (HDG) approach, the framework specializes in solving coupled partial differential equations (PDEs) on multi-arc (branch/channel) networks, with particular focus on:

\begin{itemize}
    \item \textbf{Keller-Segel chemotaxis models}: Cell migration driven by chemical gradients
    \item \textbf{Organ-on-Chip systems}: Microfluidic device simulations with multiple compartments
    \item \textbf{Multi-arc networks}: Complex geometries with different type of junction conditions and interface constraints
\end{itemize}

\subsection{Key Features}

\begin{itemize}
    \item \textbf{Multi-Arc Support}: Handle complex network topologies with arbitrary arc connections
    \item \textbf{Arbitrary equation number}: Parametric handling of the number of equations per arc
    \item \textbf{Geometry Management}: Intuitive geometry definition using the \code{DomainGeometry} class
    \item \textbf{Flexible Constraints}: Support for Neumann, Dirichlet, and Robin boundary conditions and  Kedem-Katchalsky junction conditions
    \item \textbf{Advanced Visualization}: 2D curve plots, 3D flat views, and bird's eye network visualization
    \item \textbf{Time Evolution}: Euler implicit time stepping with nonlinear solver
    \item \textbf{Static Condensation}: Efficient element-level solution elimination
   \item \textbf{Extensibility}: Adding new problem classes by writing problem specific static condensation modules 
\end{itemize}


\begin{warningbox}
	Throughout the code we use the word {\tt Domain} as a synonym of {\tt Arc}
\end{warningbox}

\input{sections2-3-4}

\section{Creating New Problems}

\subsection{Problem Structure Template}

Create a new file in \code{ooc1d/problems/} following this structure:

\begin{lstlisting}[language=Python, caption={Problem Template Structure}]
# File: ooc1d/problems/my_new_problem.py
import numpy as np
from ..core.problem import Problem
from ..core.discretization import Discretization, GlobalDiscretization
from ..core.constraints import ConstraintManager
from ..geometry import DomainGeometry

def create_global_framework():
    """
    Create a new multi-domain problem.
    Returns: problems, global_discretization, 
             constraint_manager, problem_name
    """
    # 1. Global parameters
    neq = 2  # Number of equations
    T = 1.0  # Final time
    dt = 0.1  # Time step
    problem_name = "My New Problem"
    
    # 2. Physical parameters
    parameters = np.array([param1, param2, param3, param4])
    
    # 3. Define functions (chemotaxis, sources, solutions, etc.)
    def chi(x): return np.ones_like(x)
    def dchi(x): return np.zeros_like(x)
    def source_u(s, t): return 0.0 * s
    def source_phi(s, t): return 0.0 * s
    def initial_u(s, t=0.0): return np.ones_like(s)
    def initial_phi(s, t=0.0): return np.zeros_like(s)
    
    # 4. Create geometry
    geometry = DomainGeometry("my_geometry")
    # Add domains using geometry.add_domain(...)
    
    # 5. Create problems from geometry
    problems = []
    discretizations = []
    for domain_id in range(geometry.num_domains()):
        domain_info = geometry.get_domain(domain_id)
        # Create Problem and Discretization objects
    
    # 6. Set up constraints
    constraint_manager = ConstraintManager()
    # Add boundary and interface constraints
    
    # 7. Return framework components
    return problems, global_discretization, constraint_manager, problem_name
\end{lstlisting}

\subsection{Keller-Segel Problems}

For chemotaxis problems, include:

\begin{lstlisting}[language=Python, caption={Keller-Segel Problem Setup}]
# Chemotaxis sensitivity function
def chi(x):
    k1, k2 = 3.9e-9, 5.e-6
    return k1 / (k2 + x)**2

def dchi(x):
    k1, k2 = 3.9e-9, 5.e-6
    return -k1 * 2 / (k2 + x)**3

# Set chemotaxis for all problems
for problem in problems:
    problem.set_chemotaxis(chi, dchi)
    problem.set_force(0, source_u)      # Cell equation source
    problem.set_force(1, source_phi)    # Chemical equation source
\end{lstlisting}

\subsection{Organ-on-Chip Problems}

For microfluidic systems, focus on:

\begin{lstlisting}[language=Python, caption={Organ-on-Chip Problem Setup}]
# Multi-compartment setup
compartments = ["inlet", "cell_chamber", "outlet", "waste"]

# Different parameters per compartment
parameters_list = [
    np.array([D1, v1, k1, 0.0]),     # Inlet: high flow
    np.array([D2, v2, k2, k_cell]),  # Cell chamber: cell interaction
    np.array([D3, v3, k3, 0.0]),     # Outlet: medium flow
    np.array([D4, v4, k4, 0.0])      # Waste: low flow
]

# Junction conditions with permeabilities
permeabilities = [0.8, 1.0, 0.9]  # Between compartments
\end{lstlisting}

\section{Geometry Module Guide}

\subsection{Simple Linear Network}

\begin{lstlisting}[language=Python, caption={Linear Network Geometry}]
geometry = DomainGeometry("linear_chain")

# Add sequential domains
geometry.add_domain(
    extrema_start=(0.0, 0.0),
    extrema_end=(1.0, 0.0),
    name="segment1"
)

geometry.add_domain(
    extrema_start=(1.0, 0.0),
    extrema_end=(2.0, 0.0),
    name="segment2"
)
\end{lstlisting}

\subsection{T-Junction Network}

\begin{lstlisting}[language=Python, caption={T-Junction Geometry}]
geometry = DomainGeometry("t_junction")

# Main channel
geometry.add_domain(
    extrema_start=(0.0, -1.0),
    extrema_end=(0.0, 1.0),
    name="main_channel"
)

# Side branch
geometry.add_domain(
    extrema_start=(0.0, 0.0),
    extrema_end=(1.0, 0.0),
    name="side_branch"
)
\end{lstlisting}

\subsection{Grid Network}

\begin{lstlisting}[language=Python, caption={Grid Network Geometry}]
geometry = DomainGeometry("grid_network")

# Vertical segments
for i, x_pos in enumerate([-0.5, 0.5]):
    geometry.add_domain(
        extrema_start=(x_pos, 0.0),
        extrema_end=(x_pos, 1.0),
        name=f"vertical_{i}"
    )

# Horizontal connectors
for i, y_pos in enumerate([0.2, 0.4, 0.6, 0.8]):
    geometry.add_domain(
        extrema_start=(-0.5, y_pos),
        extrema_end=(0.5, y_pos),
        name=f"horizontal_{i}"
    )
\end{lstlisting}

\subsection{Complex Branching Network}

\begin{lstlisting}[language=Python, caption={Branching Network Geometry}]
geometry = DomainGeometry("branching_network")

# Main trunk
geometry.add_domain(
    extrema_start=(0.0, 0.0),
    extrema_end=(0.0, 2.0),
    name="trunk"
)

# Branches at different levels
branch_angles = [30, 60, 120, 150]  # degrees
for i, angle in enumerate(branch_angles):
    angle_rad = np.radians(angle)
    length = 1.0
    end_x = length * np.cos(angle_rad)
    end_y = 1.0 + length * np.sin(angle_rad)
    
    geometry.add_domain(
        extrema_start=(0.0, 1.0),
        extrema_end=(end_x, end_y),
        name=f"branch_{i}"
    )
\end{lstlisting}

\section{Visualization System}

\subsection{2D Curve Plots}

Best for analyzing solution profiles along individual domains:

\begin{lstlisting}[language=Python, caption={2D Curve Plotting}]
plotter.plot_2d_curves(
    trace_solutions=solutions,
    title="Solution Profiles",
    show_mesh_points=True,
    save_filename="solution_curves.png"
)
\end{lstlisting}

\textbf{Features:}
\begin{itemize}
    \item Separate subplot per domain
    \item All equations shown in each domain
    \item Mesh point markers
    \item Domain boundary indicators
\end{itemize}

\subsection{Flat 3D View}

Ideal for understanding network topology with solution values:

\begin{lstlisting}[language=Python, caption={Flat 3D Visualization}]
plotter.plot_flat_3d(
    trace_solutions=solutions,
    equation_idx=0,
    view_angle=(30, 45),
    save_filename="network_3d.png"
)
\end{lstlisting}

\textbf{Features:}
\begin{itemize}
    \item Network segments in xy-plane
    \item Solution values as colored scatter points above
    \item Connecting lines from segments to solution points
    \item Rotatable 3D view
\end{itemize}

\subsection{Bird's Eye View}

Perfect for network-level solution analysis:

\begin{lstlisting}[language=Python, caption={Bird's Eye View Plotting}]
plotter.plot_birdview(
    trace_solutions=solutions,
    equation_idx=0,
    time=current_time,
    save_filename="network_overview.png"
)
\end{lstlisting}

\textbf{Features:}
\begin{itemize}
    \item Top-down network view
    \item Color-coded segment thickness
    \item Solution point markers
    \item Clean network overview
\end{itemize}

\clearpage
\thispagestyle{empty} % Remove headers/footers
\vspace*{\fill}

\begin{center}
	{\Huge \textbf{Chapter Title}}\\[1cm]
	{\Large Subtitle or Description (if any)}\\[2cm]
%	\includegraphics[width=0.3\textwidth]{path/to/your/image.png} % Optional image
\end{center}

\vspace*{\fill}
\clearpage

\input{domain_geometry_api}
\input{problem_module_api_accurate}
\input{constraints_module_api}
\input{discretization_module_api}
\input{bulk_data_module_api}
\input{domain_data}
\input{lean_bulk_data_manager_api}
\input{static_condensation_modules_api}
\input{flux_jump_module_api}


\input{lean_global_assembly_api}
\input{elementary_matrices_module_api}


\input{setup_solver_detailed_api}

\input{lean_matplotlib_plotter_api}

\input{problems_folder_detailed_api}

\section{Example Applications}

\subsection{Example 1: Simple Keller-Segel Chain}

\begin{lstlisting}[language=Python, caption={Simple Keller-Segel Example}]
# File: examples/simple_keller_segel.py
import sys
sys.path.insert(0, '../code')

from setup_solver import quick_setup
from ooc1d.visualization.lean_matplotlib_plotter import LeanMatplotlibPlotter

def main():
    # Setup problem
    setup = quick_setup("ooc1d.problems.KS_with_geometry", validate=True)
    
    # Get initial conditions
    trace_solutions, multipliers = setup.create_initial_conditions()
    
    # Initialize plotter
    plotter = LeanMatplotlibPlotter(
        problems=setup.problems,
        discretizations=setup.global_discretization.spatial_discretizations
    )
    
    # Plot initial state
    plotter.plot_2d_curves(trace_solutions, title="Initial State")
    plotter.plot_birdview(trace_solutions, equation_idx=0, time=0.0)
    
    # Time evolution
    dt = setup.global_discretization.dt
    T = 0.5
    current_time = 0.0
    global_solution = setup.create_global_solution_vector(
        trace_solutions, multipliers)
    
    while current_time < T:
        # Newton iteration (simplified)
        current_time += dt
        # ... solver steps ...
        
        # Extract solutions
        final_traces, _ = setup.extract_domain_solutions(global_solution)
        
        # Visualize
        plotter.plot_birdview(final_traces, equation_idx=0, 
                             time=current_time)
    
    plotter.show_all()

if __name__ == "__main__":
    main()
\end{lstlisting}

\subsection{Example 2: Complex Grid Network}

\begin{lstlisting}[language=Python, caption={Grid Network Example}]
# File: examples/grid_network_example.py
import sys
sys.path.insert(0, '../code')

from setup_solver import quick_setup
from ooc1d.visualization.lean_matplotlib_plotter import LeanMatplotlibPlotter

def main():
    # Load complex grid problem
    setup = quick_setup("ooc1d.problems.KS_grid_geometry", validate=True)
    
    print(f"Problem: {setup.get_problem_info()['problem_name']}")
    print(f"Domains: {setup.get_problem_info()['num_domains']}")
    
    # Initial conditions
    trace_solutions, multipliers = setup.create_initial_conditions()
    
    # Visualization
    plotter = LeanMatplotlibPlotter(
        problems=setup.problems,
        discretizations=setup.global_discretization.spatial_discretizations,
        figsize=(15, 10)
    )
    
    # Multiple views of initial state
    plotter.plot_2d_curves(
        trace_solutions, 
        title="Grid Network - Domain Profiles",
        save_filename="grid_profiles.png"
    )
    
    for eq_idx in range(2):  # Both equations
        plotter.plot_flat_3d(
            trace_solutions,
            equation_idx=eq_idx,
            title=f"Grid Network - {plotter.equation_names[eq_idx]} (3D)",
            save_filename=f"grid_3d_eq{eq_idx}.png"
        )
        
        plotter.plot_birdview(
            trace_solutions,
            equation_idx=eq_idx,
            time=0.0,
            save_filename=f"grid_birdview_eq{eq_idx}.png"
        )
    
    plotter.show_all()

if __name__ == "__main__":
    main()
\end{lstlisting}

\section{API Reference}

\subsection{Quick Setup Function}

\begin{lstlisting}[language=Python, caption={Quick Setup API}]
setup_solver.quick_setup(problem_module: str, 
                         validate: bool = True) -> SolverSetup
\end{lstlisting}

\textbf{Parameters:}
\begin{itemize}
    \item \code{problem\_module}: Import path to problem definition (e.g., "ooc1d.problems.my\_problem")
    \item \code{validate}: Whether to validate setup after creation
\end{itemize}

\textbf{Returns:} Configured \code{SolverSetup} object

\subsection{SolverSetup Class}

\begin{lstlisting}[language=Python, caption={SolverSetup API}]
class SolverSetup:
    def get_problem_info() -> Dict[str, Any]
    def create_initial_conditions() -> Tuple[List[np.ndarray], np.ndarray]
    def create_global_solution_vector(traces, multipliers) -> np.ndarray
    def extract_domain_solutions(global_solution) -> Tuple[List[np.ndarray], 
                                                           np.ndarray]
\end{lstlisting}

\subsection{DomainGeometry Class}

\begin{lstlisting}[language=Python, caption={DomainGeometry API}]
class DomainGeometry:
    def add_domain(extrema_start: Tuple[float, float],
                   extrema_end: Tuple[float, float],
                   domain_start: float = None,
                   domain_length: float = None,
                   name: str = None,
                   **metadata) -> int
    
    def get_domain(domain_id: int) -> DomainInfo
    def get_bounding_box() -> Dict[str, float]
    def num_domains() -> int
    def summary() -> str
\end{lstlisting}

\subsection{LeanMatplotlibPlotter Class}

\begin{lstlisting}[language=Python, caption={Plotter API}]
class LeanMatplotlibPlotter:
    def __init__(problems, discretizations, 
                 equation_names=None, figsize=(12,8))
    
    def plot_2d_curves(trace_solutions, title, 
                       show_mesh_points=True,
                       save_filename=None) -> plt.Figure
    
    def plot_flat_3d(trace_solutions, equation_idx=0, 
                     view_angle=(30,45),
                     save_filename=None) -> plt.Figure
    
    def plot_birdview(trace_solutions, equation_idx=0, 
                      time=0.0,
                      save_filename=None) -> plt.Figure
    
    def plot_comparison(initial_traces, final_traces, 
                        initial_time=0.0,
                        final_time=1.0, 
                        save_filename=None) -> plt.Figure
\end{lstlisting}



\input{project_status_report}
\input{project_todo_analysis}

\section{Troubleshooting}

\subsection{Common Issues}

\subsubsection{Import Errors}
\begin{lstlisting}[language=Python, caption={Path Setup}]
# Ensure correct path setup
import sys
sys.path.insert(0, '/path/to/BioNetFlux/code')
\end{lstlisting}

\subsubsection{Geometry Validation}
\begin{lstlisting}[language=Python, caption={Geometry Debugging}]
# Check geometry before problem creation
geometry = DomainGeometry("test")
# ... add domains ...
print(geometry.summary())  # Verify domain layout
print(geometry.get_bounding_box())  # Check coordinates
\end{lstlisting}

\subsubsection{Constraint Setup}
\begin{lstlisting}[language=Python, caption={Constraint Verification}]
# Verify constraint mapping
constraint_manager.map_to_discretizations(discretizations)
print(f"Total constraints: {constraint_manager.n_multipliers}")
\end{lstlisting}

\subsubsection{Solution Convergence}
\begin{lstlisting}[language=Python, caption={Convergence Monitoring}]
# Monitor Newton iteration
newton_tolerance = 1e-10
max_newton_iterations = 20

# Check residual norms during iteration
if residual_norm > newton_tolerance:
    print(f"Convergence issue: residual = {residual_norm:.2e}")
\end{lstlisting}

\subsection{Performance Optimization}

\begin{enumerate}
    \item \textbf{Mesh Resolution}: Balance accuracy vs. computational cost
    \item \textbf{Time Step Size}: Use adaptive time stepping for stability
    \item \textbf{Newton Tolerance}: Adjust based on problem requirements
    \item \textbf{Domain Decomposition}: Optimize domain sizes for load balancing
\end{enumerate}

\subsection{Debugging Tips}

\begin{enumerate}
    \item \textbf{Visualization}: Use all three plot types to understand solution behavior
    \item \textbf{Parameter Validation}: Check physical parameter ranges
    \item \textbf{Constraint Verification}: Ensure proper interface connectivity
    \item \textbf{Solution Monitoring}: Track solution norms and residuals
\end{enumerate}

\section{Contact and Support}

For questions, issues, or contributions:

\begin{itemize}
    \item \textbf{Repository}: [\bionetflux{} GitHub]
    \item \textbf{Documentation}: See \code{docs/} directory
    \item \textbf{Examples}: See \code{examples/} directory
    \item \textbf{Issues}: Submit via GitHub Issues
\end{itemize}

\vspace{2cm}

\begin{center}
\textbf{\bionetflux{} Development Team} \\
\textit{Multi-Domain Biological Network Flow Simulation Framework}
\end{center}

\end{document}
