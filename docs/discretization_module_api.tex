% Discretization Module API Documentation
% To be included in master LaTeX document
%
% Usage: \input{docs/discretization_module_api}

\section{Discretization Module API Reference}
\label{sec:discretization_module_api}

This section provides a comprehensive reference for the Discretization classes (\texttt{bionetflux.core.discretization}) based on the actual implementation. The module contains classes for spatial and temporal discretization management using finite elements.

\subsection{Module Overview}

The discretization module contains two main classes:
\begin{itemize}
    \item \texttt{Discretization}: Single-domain spatial discretization using finite elements
    \item \texttt{GlobalDiscretization}: Multi-domain coordinator with time stepping parameters
\end{itemize}

\subsection{Module Dependencies}

\begin{lstlisting}[language=Python, caption=Module Dependencies]
import numpy as np
from typing import List, Optional
\end{lstlisting}

\subsection{Discretization Class}
\label{subsec:discretization_class}

The main class for single-domain spatial discretization using finite elements. Handles spatial mesh generation and element properties.

\subsubsection{Constructor}

\paragraph{\_\_init\_\_()}\leavevmode
\begin{lstlisting}[language=Python, caption=Discretization Constructor]
def __init__(self, n_elements: int, domain_start: float = 0.0, 
             domain_length: float = 1.0, stab_constant: float = 1.0)
\end{lstlisting}

\textbf{Parameters:}
\begin{itemize}
    \item \texttt{n\_elements}: Number of elements in the mesh
    \item \texttt{domain\_start}: Domain start coordinate (default: 0.0)
    \item \texttt{domain\_length}: Domain length (default: 1.0)
    \item \texttt{stab\_constant}: Stabilization constant (default: 1.0)
\end{itemize}

\textbf{Description:} Creates a spatial discretization and automatically generates the mesh by calling \texttt{\_generate\_mesh()}.

\textbf{Usage Examples:}
\begin{lstlisting}[language=Python, caption=Discretization Constructor Usage]
# Basic discretization with 20 elements
disc1 = Discretization(n_elements=20)

# Custom domain discretization
disc2 = Discretization(
    n_elements=40,
    domain_start=0.0,  
    domain_length=1.0,
    stab_constant=1.0
)

# Fine mesh discretization on different domain
disc3 = Discretization(
    n_elements=100,
    domain_start=-1.0,
    domain_length=2.0,
    stab_constant=0.5
)
\end{lstlisting}

\subsubsection{Core Attributes}

\begin{longtable}{|p{3.2cm}|p{3cm}|p{7cm}|}
\hline
\textbf{Attribute} & \textbf{Type} & \textbf{Description} \\
\hline
\endhead

\texttt{n\_elements} & \texttt{int} & Number of elements in the mesh \\
\hline

\texttt{domain\_start} & \texttt{float} & Start coordinate of the domain \\
\hline

\texttt{domain\_length} & \texttt{float} & Length of the domain \\
\hline

\texttt{stab\_constant} & \texttt{float} & Stabilization constant \\
\hline

\texttt{n\_nodes} & \texttt{int} & Number of nodes: \texttt{n\_elements + 1} \\
\hline

\texttt{element\_length} & \texttt{float} & Uniform element size: \texttt{domain\_length / n\_elements} \\
\hline

\texttt{nodes} & \texttt{np.ndarray} & Node coordinates array (generated by \texttt{\_generate\_mesh}) \\
\hline

\texttt{elements} & \texttt{np.ndarray} & Element connectivity array: \texttt{[[i, i+1] for i in range(n\_elements)]} \\
\hline

\texttt{element\_centers} & \texttt{np.ndarray} & Element center coordinates \\
\hline

\texttt{tau} & \texttt{np.ndarray} & Stabilization parameters per equation (set by \texttt{set\_tau}) \\
\hline

\end{longtable}

\subsubsection{Private Methods}

\paragraph{\_generate\_mesh()}\leavevmode
\begin{lstlisting}[language=Python, caption=Generate Mesh Method]
def _generate_mesh(self)
\end{lstlisting}

\textbf{Description:} Private method that generates the spatial mesh nodes and connectivity. Called automatically during initialization.

\textbf{Implementation:}
\begin{itemize}
    \item Creates \texttt{self.nodes} using \texttt{np.linspace(domain\_start, domain\_start + domain\_length, n\_nodes)}
    \item Creates \texttt{self.elements} as \texttt{np.array([[i, i+1] for i in range(n\_elements)])}
    \item Creates \texttt{self.element\_centers} as \texttt{nodes[:-1] + element\_length / 2}
\end{itemize}

\textbf{Usage:} This method is called automatically during object initialization and should not be called directly.

\subsubsection{Public Methods}

\paragraph{get\_mesh\_info()}\leavevmode
\begin{lstlisting}[language=Python, caption=Get Mesh Info Method]
def get_mesh_info(self) -> dict
\end{lstlisting}

\textbf{Returns:} \texttt{dict} - Dictionary containing complete mesh information

\textbf{Dictionary Keys:}
\begin{itemize}
    \item \texttt{n\_elements}: Number of elements
    \item \texttt{n\_nodes}: Number of nodes
    \item \texttt{element\_length}: Element length
    \item \texttt{nodes}: Node coordinates array
    \item \texttt{elements}: Element connectivity array
    \item \texttt{element\_centers}: Element center coordinates
    \item \texttt{domain\_start}: Domain start coordinate
    \item \texttt{domain\_length}: Domain length
    \item \texttt{stab\_constant}: Stabilization constant
\end{itemize}

\textbf{Usage:}
\begin{lstlisting}[language=Python, caption=Get Mesh Info Usage]
disc = Discretization(n_elements=10, domain_start=0.0, domain_length=2.0)
mesh_info = disc.get_mesh_info()
print(f"Elements: {mesh_info['n_elements']}")
print(f"Nodes: {mesh_info['n_nodes']}")
print(f"Element length: {mesh_info['element_length']}")
print(f"First few nodes: {mesh_info['nodes'][:5]}")
\end{lstlisting}

\paragraph{set\_tau()}\leavevmode
\begin{lstlisting}[language=Python, caption=Set Tau Method]
def set_tau(self, tau_values: List[float])
\end{lstlisting}

\textbf{Parameters:}
\begin{itemize}
    \item \texttt{tau\_values}: List of stabilization parameters for each equation
\end{itemize}

\textbf{Side Effects:} Sets \texttt{self.tau} as a numpy array

\textbf{Validation:} Raises \texttt{ValueError} if \texttt{tau\_values} list is empty

\textbf{Usage:}
\begin{lstlisting}[language=Python, caption=Set Tau Usage]
# Keller-Segel problem (2 equations)
ks_disc = Discretization(n_elements=20)
ks_disc.set_tau([1.0, 1.0])  # [tau_u, tau_phi]

# OrganOnChip problem (4 equations)
ooc_disc = Discretization(n_elements=40)
ooc_disc.set_tau([1.0, 1.0, 1.0, 1.0])  # [tu, to, tv, tp]

# Different stabilization parameters
custom_disc = Discretization(n_elements=30)
custom_disc.set_tau([0.5, 2.0, 1.5])  # Custom values per equation

# This will raise ValueError
try:
    disc.set_tau([])  # Empty list
except ValueError as e:
    print(f"Error: {e}")
\end{lstlisting}



\subsection{GlobalDiscretization Class}
\label{subsec:globaldiscretization_class}

Global discretization class managing multiple spatial domains and time discretization. Coordinates temporal evolution across all domains.

\subsubsection{Constructor}

\paragraph{\_\_init\_\_()}\leavevmode
\begin{lstlisting}[language=Python, caption=GlobalDiscretization Constructor]
def __init__(self, spatial_discretizations: List[Discretization])
\end{lstlisting}

\textbf{Parameters:}
\begin{itemize}
    \item \texttt{spatial\_discretizations}: List of Discretization instances for each domain
\end{itemize}

\textbf{Description:} Creates a global discretization coordinator and automatically computes global mesh information by calling \texttt{\_compute\_global\_info()}.

\textbf{Usage:}
\begin{lstlisting}[language=Python, caption=GlobalDiscretization Usage]
# Single domain
disc1 = Discretization(n_elements=20, domain_start=0.0, domain_length=1.0)
global_disc = GlobalDiscretization([disc1])

# Multi-domain network
main_disc = Discretization(n_elements=30, domain_start=0.0, domain_length=1.0)
branch1_disc = Discretization(n_elements=20, domain_start=1.0, domain_length=0.8)
branch2_disc = Discretization(n_elements=20, domain_start=1.0, domain_length=0.8)

multi_global_disc = GlobalDiscretization([main_disc, branch1_disc, branch2_disc])
\end{lstlisting}

\subsubsection{Core Attributes}

\begin{longtable}{|p{4.6cm}|p{4cm}|p{5.5cm}|}
\hline
\textbf{Attribute} & \textbf{Type} & \textbf{Description} \\
\hline
\endhead

\texttt{spatial\_discretizations} & \texttt{List[Discretization]} & List of spatial discretizations for each domain \\
\hline

\texttt{n\_domains} & \texttt{int} & Number of domains: \texttt{len(spatial\_discretizations)} \\
\hline

\texttt{dt} & \texttt{Optional[float]} & Global time step size (initially None) \\
\hline

\texttt{T} & \texttt{Optional[float]} & Final time (initially None) \\
\hline

\texttt{n\_time\_steps} & \texttt{Optional[int]} & Number of time steps: \texttt{int(np.ceil(T/dt))} \\
\hline

\texttt{time\_points} & \texttt{Optional[np.ndarray]} & Array of time points from 0 to T \\
\hline

\texttt{total\_elements} & \texttt{int} & Sum of elements across all domains \\
\hline

\texttt{total\_nodes} & \texttt{int} & Sum of nodes across all domains \\
\hline

\end{longtable}

\subsubsection{Private Methods}

\paragraph{\_compute\_global\_info()}\leavevmode
\begin{lstlisting}[language=Python, caption=Compute Global Info Method]
def _compute_global_info(self)
\end{lstlisting}

\textbf{Description:} Private method that computes global mesh information from all domains. Called automatically during initialization.

\textbf{Implementation:}
\begin{itemize}
    \item Sets \texttt{self.total\_elements} as sum of elements from all spatial discretizations
    \item Sets \texttt{self.total\_nodes} as sum of nodes from all spatial discretizations
\end{itemize}

\textbf{Usage:} This method is called automatically during object initialization and should not be called directly.

\subsubsection{Public Methods}

\paragraph{set\_time\_parameters()}\leavevmode
\begin{lstlisting}[language=Python, caption=Set Time Parameters Method]
def set_time_parameters(self, dt: float, T: float)
\end{lstlisting}

\textbf{Parameters:}
\begin{itemize}
    \item \texttt{dt}: Time step size
    \item \texttt{T}: Final time
\end{itemize}

\textbf{Side Effects:} 
\begin{itemize}
    \item Sets \texttt{self.dt}, \texttt{self.T}, \texttt{self.n\_time\_steps}, and \texttt{self.time\_points}
    \item Calculates \texttt{n\_time\_steps = int(np.ceil(T / dt))}
    \item Creates \texttt{time\_points = np.linspace(0, T, n\_time\_steps + 1)}
\end{itemize}

\textbf{Usage:}
\begin{lstlisting}[language=Python, caption=Set Time Parameters Usage]
global_disc = GlobalDiscretization([disc1, disc2])
global_disc.set_time_parameters(dt=0.01, T=1.0)

print(f"Time step: {global_disc.dt}")
print(f"Final time: {global_disc.T}")
print(f"Number of time steps: {global_disc.n_time_steps}")
print(f"First few time points: {global_disc.time_points[:5]}")
\end{lstlisting}

\paragraph{get\_spatial\_discretization()}\leavevmode
\begin{lstlisting}[language=Python, caption=Get Spatial Discretization Method]
def get_spatial_discretization(self, domain_index: int) -> Discretization
\end{lstlisting}

\textbf{Parameters:}
\begin{itemize}
    \item \texttt{domain\_index}: Domain index (0 to \texttt{n\_domains-1})
\end{itemize}

\textbf{Returns:} \texttt{Discretization} - Spatial discretization for specified domain

\textbf{Raises:} \texttt{IndexError} if domain\_index is out of range

\textbf{Usage:}
\begin{lstlisting}[language=Python, caption=Get Spatial Discretization Usage]
try:
    domain_0_disc = global_disc.get_spatial_discretization(0)
    print(f"Domain 0 elements: {domain_0_disc.n_elements}")
    print(f"Domain 0 nodes: {domain_0_disc.n_nodes}")
    
    # This will raise IndexError if only 2 domains exist
    domain_5_disc = global_disc.get_spatial_discretization(5)
except IndexError as e:
    print(f"Error: {e}")
\end{lstlisting}

\paragraph{get\_time\_info()}\leavevmode
\begin{lstlisting}[language=Python, caption=Get Time Info Method]
def get_time_info(self) -> dict
\end{lstlisting}

\textbf{Returns:} \texttt{dict} - Dictionary containing time discretization information

\textbf{Dictionary Keys:}
\begin{itemize}
    \item \texttt{dt}: Time step size
    \item \texttt{T}: Final time
    \item \texttt{n\_time\_steps}: Number of time steps
    \item \texttt{time\_points}: Array of time points
\end{itemize}

\textbf{Usage:}
\begin{lstlisting}[language=Python, caption=Get Time Info Usage]
global_disc.set_time_parameters(dt=0.01, T=1.0)
time_info = global_disc.get_time_info()
print(f"Time step: {time_info['dt']}")
print(f"Final time: {time_info['T']}")
print(f"Number of time steps: {time_info['n_time_steps']}")
print(f"Time points shape: {time_info['time_points'].shape}")
\end{lstlisting}

\paragraph{get\_global\_info()}\leavevmode
\begin{lstlisting}[language=Python, caption=Get Global Info Method]
def get_global_info(self) -> dict
\end{lstlisting}

\textbf{Returns:} \texttt{dict} - Dictionary containing complete global discretization information

\textbf{Dictionary Keys:}
\begin{itemize}
    \item \texttt{n\_domains}: Number of domains
    \item \texttt{total\_elements}: Total number of elements across all domains
    \item \texttt{total\_nodes}: Total number of nodes across all domains
    \item \texttt{time\_info}: Time discretization information (from \texttt{get\_time\_info()})
    \item \texttt{spatial\_discretizations}: List of mesh information for each domain
\end{itemize}

\textbf{Usage:}
\begin{lstlisting}[language=Python, caption=Get Global Info Usage]
global_disc.set_time_parameters(dt=0.01, T=1.0)
global_info = global_disc.get_global_info()

print(f"Number of domains: {global_info['n_domains']}")
print(f"Total elements: {global_info['total_elements']}")
print(f"Total nodes: {global_info['total_nodes']}")

# Access time information
time_info = global_info['time_info']
print(f"Time step: {time_info['dt']}")

# Access spatial discretization info for each domain
for i, spatial_info in enumerate(global_info['spatial_discretizations']):
    print(f"Domain {i}: {spatial_info['n_elements']} elements")
\end{lstlisting}

\subsection{Complete Usage Examples}
\label{subsec:discretization_complete_examples}

\subsubsection{Single Domain Setup}

\begin{lstlisting}[language=Python, caption=Single Domain Discretization Setup]
from bionetflux.core.discretization import Discretization, GlobalDiscretization

# Create spatial discretization for a single domain
spatial_disc = Discretization(
    n_elements=40,
    domain_start=0.0,
    domain_length=1.0,
    stab_constant=1.0
)

# Set stabilization parameters (e.g., for Keller-Segel: 2 equations)
spatial_disc.set_tau([1.0, 1.0])

# Create global discretization
global_disc = GlobalDiscretization([spatial_disc])

# Set time parameters
global_disc.set_time_parameters(dt=0.01, T=1.0)

# Access mesh information
mesh_info = spatial_disc.get_mesh_info()
print(f"Elements: {mesh_info['n_elements']}")
print(f"Nodes: {mesh_info['n_nodes']}")
print(f"Element length: {mesh_info['element_length']}")

# Access global information
global_info = global_disc.get_global_info()
print(f"Total elements: {global_info['total_elements']}")
print(f"Time steps: {global_info['time_info']['n_time_steps']}")
\end{lstlisting}

\subsubsection{Multi-Domain Network Setup}

\begin{lstlisting}[language=Python, caption=Multi-Domain Network Discretization]
# Create multiple spatial discretizations for network domains
main_disc = Discretization(n_elements=30, domain_start=0.0, domain_length=1.0)
branch1_disc = Discretization(n_elements=20, domain_start=1.0, domain_length=0.8)
branch2_disc = Discretization(n_elements=20, domain_start=1.0, domain_length=0.8)

# Set stabilization parameters for each domain
main_disc.set_tau([1.0, 1.0, 1.0, 1.0])     # 4-equation system
branch1_disc.set_tau([1.0, 1.0, 1.0, 1.0])  # 4-equation system  
branch2_disc.set_tau([1.0, 1.0, 1.0, 1.0])  # 4-equation system

# Create global discretization for the network
network_global_disc = GlobalDiscretization([main_disc, branch1_disc, branch2_disc])

# Set global time parameters
network_global_disc.set_time_parameters(dt=0.01, T=0.5)

# Access individual domain discretizations
domain_0 = network_global_disc.get_spatial_discretization(0)
print(f"Main domain elements: {domain_0.n_elements}")

# Get global statistics
global_info = network_global_disc.get_global_info()
print(f"Network has {global_info['n_domains']} domains")
print(f"Total elements: {global_info['total_elements']}")
print(f"Total nodes: {global_info['total_nodes']}")
\end{lstlisting}

\subsection{Method Summary Tables}
\label{subsec:discretization_method_summary}

\subsubsection{Discretization Class Methods}

\begin{longtable}{|p{4.0cm}|p{2.5cm}|p{6.5cm}|}
\hline
\textbf{Method} & \textbf{Returns} & \textbf{Purpose} \\
\hline
\endhead

\texttt{\_generate\_mesh} & \texttt{None} & Generate spatial mesh (private, called during init) \\
\hline

\texttt{get\_mesh\_info} & \texttt{dict} & Return complete mesh information dictionary \\
\hline

\texttt{set\_tau} & \texttt{None} & Set stabilization parameters per equation \\
\hline

\end{longtable}

\subsubsection{GlobalDiscretization Class Methods}

\begin{longtable}{|p{5.2cm}|p{2.7cm}|p{6cm}|}
\hline
\textbf{Method} & \textbf{Returns} & \textbf{Purpose} \\
\hline
\endhead

\texttt{\_compute\_global\_info} & \texttt{None} & Compute global mesh info (private, called during init) \\
\hline

\texttt{set\_time\_parameters} & \texttt{None} & Set global time step and final time \\
\hline

\texttt{get\_spatial\_discretization} & \texttt{Discretization} & Access specific domain discretization \\
\hline

\texttt{get\_time\_info} & \texttt{dict} & Return time discretization information \\
\hline

\texttt{get\_global\_info} & \texttt{dict} & Return complete global discretization information \\
\hline

\end{longtable}

This documentation provides an exact reference for the Discretization module based on the actual BioNetFlux implementation in \texttt{bionetflux.core.discretization}.

\begin{todobox}
	\begin{itemize}
		\item Check doubling of information with geometry module
		\item Should the stabilization parameter be an attribute of the Discretization class? Probably not. Evaluate options. Modification has (positive) impact for {\tt static\_condensation}
		\item Allow for non uniform grids
		\item Allow for non uniform time stepping
		\item Include P\'eclet number checks and checks of requirements on {\tt dt} vs {\tt h}
		\end{itemize}
	\end{todobox}

% End of discretization module API documentation
