% Time Stepper Module Detailed API Documentation
% To be included in master LaTeX document
%
% Usage: \input{docs/time_stepper_module_api}

\section{Time Stepper Module Detailed API Reference}
\label{sec:time_stepper_module_api}

This section provides an exact reference for the time stepper module (\texttt{time\_stepper.py}). The module provides comprehensive time advancement functionality for BioNetFlux simulations, encapsulating complex Newton iteration and bulk data management in clean, modular interfaces.

\subsection{Module Overview}

The time stepper module provides:
\begin{itemize}
    \item Single time step advancement using implicit Euler + Newton iteration
    \item Complete encapsulation of Newton solver integration and bulk data management
    \item Initialization of solution state at t=0 from problem definitions
    \item Multi-step advancement for batch time evolution
    \item Adaptive time stepping with automatic dt control
    \item Comprehensive error handling and convergence monitoring
    \item Integration with BioNetFlux Newton solver and bulk data systems
\end{itemize}


\begin{warningbox}
	The timestep is presently hardcoded in the static condensation functions. In order to use adaptive time stepping (which is definitely desirable) the static condensation module must be redesigned.
\end{warningbox}

\subsection{Module Imports and Dependencies}

\begin{lstlisting}[language=Python, caption=Module Dependencies]
import numpy as np
import time
from dataclasses import dataclass
from typing import List, Optional, Tuple
from .newton_solver import NewtonSolver, NewtonResult
from .time_step_result import TimeStepResult
\end{lstlisting}

\subsection{TimeStepResult Class}
\label{subsec:time_step_result_class}

Main dataclass that encapsulates all information about a single time step computation, including convergence status, iteration details, and performance metrics.

\subsubsection{Class Definition}

\begin{lstlisting}[language=Python, caption=TimeStepResult Class Definition]
	@dataclass
	class TimeStepResult:
	"""Container for time step results and convergence information."""
	
	# Core results
	converged: bool
	iterations: int
	final_residual_norm: float
	updated_solution: np.ndarray
	updated_bulk_data: List
	computation_time: float
	
	# Optional detailed info
	residual_history: Optional[List[float]] = None
	jacobian_condition: Optional[float] = None
	newton_step_norms: Optional[List[float]] = None
\end{lstlisting}

\subsubsection{Core Attributes}

\begin{longtable}{|p{4.5cm}|p{3.5cm}|p{6cm}|}
	\hline
	\textbf{Attribute} & \textbf{Type} & \textbf{Description} \\
	\hline
	\endhead
	
	\texttt{converged} & \texttt{bool} & Convergence status of the time step computation \\
	\hline
	
	\texttt{iterations} & \texttt{int} & Number of Newton iterations performed \\
	\hline
	
	\texttt{final\_residual\_norm} & \texttt{float} & Final L2 norm of the residual vector \\
	\hline
	
	\texttt{updated\_solution} & \texttt{np.ndarray} & Global solution vector at new time step \\
	\hline
	
	\texttt{updated\_bulk\_data} & \texttt{List} & List of updated BulkData objects for all domains \\
	\hline
	
	\texttt{computation\_time} & \texttt{float} & Total wall-clock time for time step computation (seconds) \\
	\hline
	
\end{longtable}

\subsubsection{Optional Detailed Attributes}

\begin{longtable}{|p{4.5cm}|p{4.2cm}|p{6cm}|}
	\hline
	\textbf{Attribute} & \textbf{Type} & \textbf{Description} \\
	\hline
	\endhead
	
	\texttt{residual\_history} & \texttt{Optional[List[float]]} & Residual norm at each Newton iteration (None if not tracked) \\
	\hline
	
	\texttt{jacobian\_condition} & \texttt{Optional[float]} & Condition number of final Jacobian matrix (None if not computed) \\
	\hline
	
	\texttt{newton\_step\_norms} & \texttt{Optional[List[float]]} & L2 norm of Newton step at each iteration (None if not tracked) \\
	\hline
	
\end{longtable}

\subsubsection{String Representation Methods}

\paragraph{\_\_str\_\_()}\leavevmode
\begin{lstlisting}[language=Python, caption=String Representation Method]
	def __str__(self) -> str:
	status = "CONVERGED" if self.converged else "FAILED"
	return (f"TimeStepResult({status}, {self.iterations} iterations, "
	f"residual={self.final_residual_norm:.6e}, "
	f"time={self.computation_time:.4f}s)")
\end{lstlisting}

\textbf{Returns:} \texttt{str} - Compact string representation with key metrics

\textbf{Example Output:}
\begin{lstlisting}[language=Python, caption=Example String Output]
	TimeStepResult(CONVERGED, 5 iterations, residual=1.234567e-11, time=0.0234s)
	TimeStepResult(FAILED, 20 iterations, residual=2.345678e-05, time=0.1456s)
\end{lstlisting}

\textbf{Usage:}
\begin{lstlisting}[language=Python, caption=String Representation Usage]
	result = time_stepper.advance_time_step(current_solution, current_bulk_data, 
	current_time, dt)
	print(result)  # Prints compact summary
	print(f"Status: {result}")  # Same output in formatted string
\end{lstlisting}

\paragraph{summary()}\leavevmode
\begin{lstlisting}[language=Python, caption=Summary Method]
	def summary(self) -> str:
	"""Generate a detailed summary string."""
\end{lstlisting}

\textbf{Returns:} \texttt{str} - Detailed multi-line summary with comprehensive information

\textbf{Algorithm:}
\begin{lstlisting}[language=Python, caption=Summary Method Implementation]
	def summary(self) -> str:
	"""Generate a detailed summary string."""
	lines = [
	f"Time Step Result Summary:",
	f"  Status: {'CONVERGED' if self.converged else 'FAILED TO CONVERGE'}",
	f"  Newton iterations: {self.iterations}",
	f"  Final residual norm: {self.final_residual_norm:.6e}",
	f"  Computation time: {self.computation_time:.4f} seconds",
	f"  Solution vector size: {len(self.updated_solution)}",
	f"  Bulk data domains: {len(self.updated_bulk_data)}"
	]
	
	if self.jacobian_condition is not None:
	lines.append(f"  Final Jacobian condition: {self.jacobian_condition:.2e}")
	
	if self.residual_history is not None:
	lines.append(f"  Residual reduction: {self.residual_history[0]:.2e} → {self.residual_history[-1]:.2e}")
	
	return "\n".join(lines)
\end{lstlisting}

\textbf{Example Output:}
\begin{lstlisting}[language=Python, caption=Example Summary Output]
	Time Step Result Summary:
	Status: CONVERGED
	Newton iterations: 5
	Final residual norm: 1.234567e-11
	Computation time: 0.0234 seconds
	Solution vector size: 168
	Bulk data domains: 3
	Final Jacobian condition: 2.34e+03
	Residual reduction: 1.23e-02 → 1.23e-11
\end{lstlisting}

\textbf{Usage:}
\begin{lstlisting}[language=Python, caption=Summary Usage]
	result = time_stepper.advance_time_step(current_solution, current_bulk_data, 
	current_time, dt)
	print(result.summary())  # Prints detailed information
	
	# Write to file
	with open("time_step_results.txt", "a") as f:
	f.write(f"Time step {step_number}:\n")
	f.write(result.summary())
	f.write("\n" + "="*50 + "\n")
\end{lstlisting}

\subsection{TimeStepper Class}
\label{subsec:time_stepper_class}

Main class that coordinates single time step advancement using implicit Euler with Newton iteration. This class encapsulates all the logic needed to advance a BioNetFlux solution by one time step, replacing complex while loop implementations in examples.

\subsubsection{Class Definition}

\begin{lstlisting}[language=Python, caption=TimeStepper Class Definition]
class TimeStepper:
    """
    Coordinates single time step advancement using implicit Euler + Newton.
    
    This class encapsulates all the logic needed to advance a BioNetFlux
    solution by one time step, replacing the complex while loop in examples.
    """
\end{lstlisting}

\subsubsection{Constructor}

\paragraph{\_\_init\_\_()}\leavevmode
\begin{lstlisting}[language=Python, caption=TimeStepper Constructor]
def __init__(self, setup, newton_solver: Optional[NewtonSolver] = None,
             verbose: bool = True):
\end{lstlisting}

\textbf{Parameters:}
\begin{itemize}
    \item \texttt{setup}: SolverSetup instance with all framework components
    \item \texttt{newton\_solver}: Newton solver instance (creates default if None)
    \item \texttt{verbose}: Whether to print progress information (default: True)
\end{itemize}

\textbf{Side Effects:}
\begin{itemize}
    \item Sets \texttt{self.setup} to provided SolverSetup instance
    \item Creates or assigns Newton solver with verbose setting
    \item Caches frequently used components for performance
    \item Sets verbose flag for progress reporting
\end{itemize}

\textbf{Cached Components:}
\begin{lstlisting}[language=Python, caption=Component Caching in Constructor]
# Cache frequently used components
self.bulk_manager = setup.bulk_data_manager
self.global_assembler = setup.global_assembler
self.static_condensations = setup.static_condensations
self.problems = setup.problems
self.discretizations = setup.global_discretization.spatial_discretizations
\end{lstlisting}

\textbf{Usage:}
\begin{lstlisting}[language=Python, caption=TimeStepper Constructor Usage]
# Basic initialization with default Newton solver
time_stepper = TimeStepper(setup, verbose=True)

# Custom Newton solver configuration
custom_newton = NewtonSolver(tolerance=1e-12, max_iterations=25)
time_stepper = TimeStepper(setup, newton_solver=custom_newton, verbose=False)

# Silent operation
time_stepper = TimeStepper(setup, verbose=False)
\end{lstlisting}

\subsubsection{Core Attributes}

\begin{longtable}{|p{4.5cm}|p{3cm}|p{6.5cm}|}
\hline
\textbf{Attribute} & \textbf{Type} & \textbf{Description} \\
\hline
\endhead

\texttt{setup} & \texttt{SolverSetup} & Complete solver setup with all framework components \\
\hline

\texttt{newton\_solver} & \texttt{NewtonSolver} & Newton solver instance for nonlinear system solution \\
\hline

\texttt{verbose} & \texttt{bool} & Flag controlling progress output verbosity \\
\hline

\texttt{bulk\_manager} & \texttt{BulkDataManager} & Cached bulk data manager for efficiency \\
\hline

\texttt{global\_assembler} & \texttt{GlobalAssembler} & Cached global assembler for system assembly \\
\hline

\texttt{static\_condensations} & \texttt{List} & Cached static condensation implementations \\
\hline

\texttt{problems} & \texttt{List} & Cached problem instances for all domains \\
\hline

\texttt{discretizations} & \texttt{List} & Cached spatial discretizations for all domains \\
\hline

\end{longtable}

\subsubsection{Solution Initialization}

\paragraph{initialize\_solution()}\leavevmode
\begin{lstlisting}[language=Python, caption=Initialize Solution Method]
def initialize_solution(self) -> Tuple[np.ndarray, List]:
\end{lstlisting}

\textbf{Returns:} \texttt{Tuple[np.ndarray, List]} - (current\_solution, current\_bulk\_data) at t=0

\textbf{Purpose:} Initialize the solution at time t=0, setting up the initial global solution vector and bulk data. This method corresponds to Step 3, Step 4, and lines 226-233 of the original evolution example.

\textbf{Algorithm:}
\begin{lstlisting}[language=Python, caption=Solution Initialization Algorithm]
# Create initial conditions (trace solutions and multipliers)
trace_solutions, multipliers = self.setup.create_initial_conditions()

# Assemble global solution vector
current_solution = self.setup.create_global_solution_vector(trace_solutions, multipliers)

# Initialize bulk data for all domains
current_bulk_data = self.bulk_manager.initialize_all_bulk_data(
    problems=self.problems,
    discretizations=self.discretizations,
    time=0.0
)

return current_solution, current_bulk_data
\end{lstlisting}

\textbf{Process Flow:}
\begin{enumerate}
    \item Create initial trace solutions and multipliers from problem definitions
    \item Assemble global solution vector from domain traces and multipliers
    \item Initialize bulk data for all domains at t=0
    \item Return both global solution and bulk data for time stepping
\end{enumerate}

\textbf{Usage:}
\begin{lstlisting}[language=Python, caption=Solution Initialization Usage]
# Initialize at t=0
current_solution, current_bulk_data = time_stepper.initialize_solution()

print(f"Initial solution shape: {current_solution.shape}")
print(f"Initial bulk data domains: {len(current_bulk_data)}")

# Use in time evolution loop
while current_time < T:
    result = time_stepper.advance_time_step(
        current_solution, current_bulk_data, current_time, dt
    )
    # ... handle result
\end{lstlisting}

\subsubsection{Time Step Advancement}

\paragraph{advance\_time\_step()}\leavevmode
\begin{lstlisting}[language=Python, caption=Advance Time Step Method]
def advance_time_step(self, 
                     current_solution: np.ndarray,
                     current_bulk_data: List, 
                     current_time: float,
                     dt: float) -> TimeStepResult:
\end{lstlisting}

\textbf{Parameters:}
\begin{itemize}
    \item \texttt{current\_solution}: Global solution vector at current time
    \item \texttt{current\_bulk\_data}: List of BulkData objects at current time
    \item \texttt{current\_time}: Current simulation time
    \item \texttt{dt}: Time step size
\end{itemize}

\textbf{Returns:} \texttt{TimeStepResult} - Comprehensive result containing updated solution and convergence information

\textbf{Purpose:} Advance the simulation by one time step using implicit Euler + Newton. This method replaces the entire while loop body from the original evolution example.

\textbf{Algorithm Overview:}
\begin{enumerate}
    \item Compute source terms at new time t + dt
    \item Assemble forcing terms for static condensation
    \item Solve nonlinear system using Newton solver
    \item Update bulk data via static condensation
    \item Return comprehensive time step result
\end{enumerate}

\textbf{Detailed Algorithm:}
\begin{lstlisting}[language=Python, caption=Time Step Advancement Algorithm]
start_time = time.time()
new_time = current_time + dt

# Step 1: Compute source terms at new time
try:
    source_terms = self.bulk_manager.compute_source_terms(
        problems=self.problems,
        discretizations=self.discretizations,
        time=new_time
    )
except Exception as e:
    return self._create_failed_result(current_solution, current_bulk_data, 
                                    f"Source computation failed: {e}",
                                    time.time() - start_time)

# Step 2: Assemble forcing terms (right-hand side) for static condensation
try:
    forcing_terms = []
    for i, (bulk_sol, source, static_cond) in enumerate(
        zip(current_bulk_data, source_terms, self.static_condensations)):
        
        forcing_term = static_cond.assemble_forcing_term(
            previous_bulk_solution=bulk_sol.data,
            external_force=source.data
        )
        forcing_terms.append(forcing_term)
    
except Exception as e:
    return self._create_failed_result(current_solution, current_bulk_data,
                                    f"Forcing assembly failed: {e}",
                                    time.time() - start_time)

# Step 3: Solve nonlinear system using BioNetFlux-specific Newton solver

newton_result = self.newton_solver.solve(
    initial_guess=current_solution,  # Use current_solution directly as Newton initial guess
    global_assembler=self.global_assembler,
    forcing_terms=forcing_terms,
    static_condensations=self.static_condensations,
    current_time=new_time  # Updated parameter name
)

if not newton_result.converged:
    return TimeStepResult(
        converged=False,
        iterations=newton_result.iterations,
        final_residual_norm=newton_result.final_residual_norm,
        updated_solution=newton_result.final_solution,
        updated_bulk_data=current_bulk_data,  # Keep old bulk data
        computation_time=time.time() - start_time,
        residual_history=newton_result.residual_history,
        jacobian_condition=newton_result.jacobian_condition,
        newton_step_norms=newton_result.step_norms
    )

# Step 4: Update bulk data via static condensation
try:
    updated_bulk_solutions = self.global_assembler.bulk_by_static_condensation(
        global_solution=newton_result.final_solution,
        forcing_terms=forcing_terms,
        static_condensations=self.static_condensations,
        time=new_time
    )
    
    # Update bulk_data objects with new solutions
    updated_bulk_data = []
    for i, new_bulk_array in enumerate(updated_bulk_solutions):
        # Create new BulkData object
        new_bulk_data = self.bulk_manager.create_bulk_data(
            domain_index=i,
            problem=self.problems[i],
            discretization=self.discretizations[i]
        )
        # Directly set the data array
        new_bulk_data.data = new_bulk_array.copy()
        updated_bulk_data.append(new_bulk_data)
        
except Exception as e:
    # Still return the Newton solution, but with old bulk data
    updated_bulk_data = current_bulk_data

# Step 5: Create and return successful result
total_time = time.time() - start_time


return TimeStepResult(
    converged=True,
    iterations=newton_result.iterations,
    final_residual_norm=newton_result.final_residual_norm,
    updated_solution=newton_result.final_solution,
    updated_bulk_data=updated_bulk_data,
    computation_time=total_time,
    residual_history=newton_result.residual_history,
    jacobian_condition=newton_result.jacobian_condition,
    newton_step_norms=newton_result.step_norms
)
\end{lstlisting}

\textbf{Error Handling:} Uses \texttt{\_create\_failed\_result()} helper for consistent error reporting

\textbf{Usage:}
\begin{lstlisting}[language=Python, caption=Time Step Advancement Usage]
# Single time step
result = time_stepper.advance_time_step(
    current_solution=current_solution,
    current_bulk_data=current_bulk_data,
    current_time=current_time,
    dt=dt
)

# Handle result
if result.converged:
    print(f"✓ Step successful: {result}")
    # Update state
    current_time += dt
    current_solution = result.updated_solution
    current_bulk_data = result.updated_bulk_data
else:
    print(f"✗ Step failed: {result}")
    print(result.summary())
    break
\end{lstlisting}

\paragraph{\_create\_failed\_result()}\leavevmode
\begin{lstlisting}[language=Python, caption=Create Failed Result Helper]
def _create_failed_result(self, solution, bulk_data, error_msg, comp_time):
\end{lstlisting}

\textbf{Parameters:}
\begin{itemize}
    \item \texttt{solution}: Current solution to preserve
    \item \texttt{bulk\_data}: Current bulk data to preserve
    \item \texttt{error\_msg}: Error message string
    \item \texttt{comp\_time}: Computation time so far
\end{itemize}

\textbf{Returns:} \texttt{TimeStepResult} - Failed result with error information

\textbf{Purpose:} Helper method to create consistent failed TimeStepResult objects

\textbf{Implementation:}
\begin{lstlisting}[language=Python, caption=Failed Result Creation]
if self.verbose:
    print(f"    ✗ Time step failed: {error_msg}")

return TimeStepResult(
    converged=False,
    iterations=0,
    final_residual_norm=np.inf,
    updated_solution=solution,
    updated_bulk_data=bulk_data,
    computation_time=comp_time
)
\end{lstlisting}

\subsubsection{Multi-Step Advancement}

\paragraph{advance\_multiple\_steps()}\leavevmode
\begin{lstlisting}[language=Python, caption=Advance Multiple Steps Method]
def advance_multiple_steps(self, 
                          initial_solution: np.ndarray,
                          initial_bulk_data: List,
                          start_time: float,
                          dt: float,
                          n_steps: int,
                          stop_on_failure: bool = True) -> List[TimeStepResult]:
\end{lstlisting}

\textbf{Parameters:}
\begin{itemize}
    \item \texttt{initial\_solution}: Starting global solution
    \item \texttt{initial\_bulk\_data}: Starting bulk data
    \item \texttt{start\_time}: Starting time
    \item \texttt{dt}: Time step size
    \item \texttt{n\_steps}: Number of steps to take
    \item \texttt{stop\_on\_failure}: Whether to stop if a step fails (default: True)
\end{itemize}

\textbf{Returns:} \texttt{List[TimeStepResult]} - List of time step results, one per step

\textbf{Algorithm:}
\begin{lstlisting}[language=Python, caption=Multiple Steps Algorithm]
results = []
current_solution = initial_solution.copy()
current_bulk_data = initial_bulk_data
current_time = start_time

if self.verbose:
    print(f"TimeStepper: advancing {n_steps} steps from t={start_time:.6f}")

for step in range(n_steps):
    if self.verbose:
        print(f"\n--- Time Step {step + 1}/{n_steps} ---")
    
    result = self.advance_time_step(
        current_solution=current_solution,
        current_bulk_data=current_bulk_data,
        current_time=current_time,
        dt=dt
    )
    
    results.append(result)
    
    if not result.converged:
        if self.verbose:
            print(f"  ✗ Step {step + 1} failed")
        if stop_on_failure:
            if self.verbose:
                print(f"  Stopping due to convergence failure")
            break
    else:
        # Update state for next iteration
        current_solution = result.updated_solution
        current_bulk_data = result.updated_bulk_data
        current_time += dt

if self.verbose:
    successful_steps = sum(1 for r in results if r.converged)
    print(f"\nMulti-step advancement: {successful_steps}/{len(results)} steps successful")

return results
\end{lstlisting}

\textbf{Usage:}
\begin{lstlisting}[language=Python, caption=Multiple Steps Usage]
# Advance 10 time steps
results = time_stepper.advance_multiple_steps(
    initial_solution=current_solution,
    initial_bulk_data=current_bulk_data,
    start_time=0.0,
    dt=0.01,
    n_steps=10,
    stop_on_failure=True
)

# Analyze results
successful_steps = sum(1 for r in results if r.converged)
print(f"Success rate: {successful_steps/len(results)*100:.1f}%")

# Get final state
if results[-1].converged:
    final_solution = results[-1].updated_solution
    final_bulk_data = results[-1].updated_bulk_data
\end{lstlisting}

\subsubsection{Adaptive Time Stepping}

\begin{warningbox}
	Adaptive time stepping is presently not compatible with how static condensation is implemented (\tt{dt} is hard coded in the precomputed matrices)
\end{warningbox}

\paragraph{get\_adaptive\_stepper()}\leavevmode
\begin{lstlisting}[language=Python, caption=Get Adaptive Stepper Method]
def get_adaptive_stepper(self, dt_min: float = 1e-6, dt_max: float = 1.0,
                       safety_factor: float = 0.8) -> 'AdaptiveTimeStepper':
\end{lstlisting}

\textbf{Parameters:}
\begin{itemize}
    \item \texttt{dt\_min}: Minimum allowed time step (default: 1e-6)
    \item \texttt{dt\_max}: Maximum allowed time step (default: 1.0)
    \item \texttt{safety\_factor}: Safety factor for time step adjustment (default: 0.8)
\end{itemize}

\textbf{Returns:} \texttt{AdaptiveTimeStepper} - Adaptive time stepper instance

\textbf{Implementation:}
\begin{lstlisting}[language=Python, caption=Adaptive Stepper Creation]
return AdaptiveTimeStepper(
    self.setup, self.newton_solver, self.verbose,
    dt_min, dt_max, safety_factor
)
\end{lstlisting}

\textbf{Usage:}
\begin{lstlisting}[language=Python, caption=Adaptive Stepper Usage]
# Get adaptive stepper
adaptive_stepper = time_stepper.get_adaptive_stepper(
    dt_min=1e-6, dt_max=0.1, safety_factor=0.8
)

# Use adaptive stepping
result, next_dt = adaptive_stepper.advance_time_step_adaptive(
    current_solution, current_bulk_data, current_time, dt_suggested
)
\end{lstlisting}

\subsection{AdaptiveTimeStepper Class}
\label{subsec:adaptive_time_stepper_class}

Extension of TimeStepper that automatically adjusts dt based on Newton convergence performance.

\subsubsection{Class Definition}

\begin{lstlisting}[language=Python, caption=AdaptiveTimeStepper Class Definition]
class AdaptiveTimeStepper(TimeStepper):
    """
    Time stepper with adaptive time step control.
    
    Extends TimeStepper to automatically adjust dt based on Newton convergence.
    """
\end{lstlisting}

\subsubsection{Constructor}

\paragraph{\_\_init\_\_()}\leavevmode
\begin{lstlisting}[language=Python, caption=AdaptiveTimeStepper Constructor]
def __init__(self, setup, newton_solver=None, verbose=True,
             dt_min=1e-6, dt_max=1.0, safety_factor=0.8):
\end{lstlisting}

\textbf{Parameters:}
\begin{itemize}
    \item \texttt{setup}: SolverSetup instance
    \item \texttt{newton\_solver}: Newton solver (created if None)
    \item \texttt{verbose}: Print progress information
    \item \texttt{dt\_min}: Minimum time step
    \item \texttt{dt\_max}: Maximum time step
    \item \texttt{safety\_factor}: Factor for time step adjustment
\end{itemize}

\textbf{Implementation:}
\begin{lstlisting}[language=Python, caption=AdaptiveTimeStepper Constructor Implementation]
super().__init__(setup, newton_solver, verbose)
self.dt_min = dt_min
self.dt_max = dt_max
self.safety_factor = safety_factor
\end{lstlisting}

\subsubsection{Adaptive Time Step Control}

\paragraph{advance\_time\_step\_adaptive()}\leavevmode
\begin{lstlisting}[language=Python, caption=Adaptive Time Step Method]
def advance_time_step_adaptive(self, 
                              current_solution: np.ndarray,
                              current_bulk_data: List,
                              current_time: float,
                              dt_suggested: float) -> Tuple[TimeStepResult, float]:
\end{lstlisting}

\textbf{Parameters:}
\begin{itemize}
    \item \texttt{current\_solution}: Current global solution
    \item \texttt{current\_bulk\_data}: Current bulk data
    \item \texttt{current\_time}: Current time
    \item \texttt{dt\_suggested}: Suggested time step size
\end{itemize}

\textbf{Returns:} \texttt{Tuple[TimeStepResult, float]} - (result, dt\_next) where dt\_next is suggested next step

\textbf{Adaptive Algorithm:}
\begin{lstlisting}[language=Python, caption=Adaptive Time Stepping Algorithm]
dt_current = max(self.dt_min, min(dt_suggested, self.dt_max))
max_retries = 5

if self.verbose:
    print(f"  AdaptiveTimeStepper: trying dt={dt_current:.6f}")

for retry in range(max_retries):
    # Try time step with current dt
    result = self.advance_time_step(
        current_solution, current_bulk_data, current_time, dt_current
    )
    
    if result.converged:
        # Success! Suggest next time step based on Newton performance
        if result.iterations <= 3:
            # Converged quickly - can increase dt
            dt_next = min(dt_current * 1.2, self.dt_max)
            if self.verbose and dt_next > dt_current:
                print(f"    → Increasing dt: {dt_current:.6f} → {dt_next:.6f}")
        elif result.iterations <= 8:
            # Reasonable convergence - keep dt
            dt_next = dt_current
        else:
            # Slow convergence - reduce dt for next step
            dt_next = max(dt_current * 0.8, self.dt_min)
            if self.verbose and dt_next < dt_current:
                print(f"    → Decreasing dt for next step: {dt_current:.6f} → {dt_next:.6f}")
        
        return result, dt_next
    
    else:
        # Failed to converge - reduce dt and retry
        dt_current = max(dt_current * 0.5, self.dt_min)
        
        if dt_current <= self.dt_min:
            if self.verbose:
                print(f"    ✗ Reached minimum dt={self.dt_min:.2e}, giving up")
            return result, self.dt_min
        
        if self.verbose:
            print(f"    Retry {retry + 1}: reducing dt to {dt_current:.6f}")

# All retries failed
if self.verbose:
    print(f"    ✗ All {max_retries} retries failed")

return result, dt_current
\end{lstlisting}

\textbf{Adaptation Strategy:}
\begin{itemize}
    \item \textbf{Fast Convergence} (≤ 3 iterations): Increase dt by 20\%
    \item \textbf{Normal Convergence} (≤ 8 iterations): Keep current dt
    \item \textbf{Slow Convergence} (> 8 iterations): Reduce dt by 20\%
    \item \textbf{Convergence Failure}: Halve dt and retry up to 5 times
\end{itemize}

\textbf{Usage:}
\begin{lstlisting}[language=Python, caption=Adaptive Time Step Usage]
# Adaptive time stepping loop
dt_current = setup.global_discretization.dt
current_time = 0.0
max_time = 1.0

while current_time < max_time:
    result, dt_next = adaptive_stepper.advance_time_step_adaptive(
        current_solution=current_solution,
        current_bulk_data=current_bulk_data,
        current_time=current_time,
        dt_suggested=dt_current
    )
    
    if result.converged:
        current_time += dt_current
        current_solution = result.updated_solution
        current_bulk_data = result.updated_bulk_data
        dt_current = dt_next
        print(f"✓ t={current_time:.6f}, dt={dt_current:.6f}, Newton its={result.iterations}")
    else:
        print("✗ Adaptive stepping failed")
        break
\end{lstlisting}

\subsection{Complete Usage Examples}
\label{subsec:complete_time_stepper_examples}

\subsubsection{Basic Time Evolution}

\begin{lstlisting}[language=Python, caption=Basic Time Evolution Example]
from bionetflux.time_integration import TimeStepper
from setup_solver import quick_setup

def basic_time_evolution_example():
    """Basic time evolution using TimeStepper."""
    
    # Setup solver
    setup = quick_setup("bionetflux.problems.reduced_ooc_problem", validate=True)
    
    # Create time stepper
    time_stepper = TimeStepper(setup, verbose=True)
    
    # Initialize at t=0
    current_solution, current_bulk_data = time_stepper.initialize_solution()
    
    # Time evolution parameters
    dt = setup.global_discretization.dt
    T = min(0.5, setup.global_discretization.T)
    current_time = 0.0
    
    print(f"Starting time evolution: dt={dt}, T={T}")
    
    # Time evolution loop - SIMPLIFIED!
    step_count = 0
    max_steps = int(T / dt) + 1
    
    while current_time + dt <= T and step_count < max_steps:
        step_count += 1
        print(f"\n--- Step {step_count} ---")
        
        # Single line replaces ~50 lines of Newton iteration code!
        result = time_stepper.advance_time_step(
            current_solution, current_bulk_data, current_time, dt
        )
        
        if result.converged:
            print(f"✓ Success: {result.iterations} Newton its, "
                  f"||R||={result.final_residual_norm:.2e}")
            
            # Update state
            current_time += dt
            current_solution = result.updated_solution
            current_bulk_data = result.updated_bulk_data
        else:
            print(f"✗ Failed: {result}")
            break
    
    print(f"\nEvolution completed: {step_count} steps, final t={current_time:.6f}")
    return setup, time_stepper, current_solution

# Run example
setup, stepper, final_solution = basic_time_evolution_example()
\end{lstlisting}

\subsubsection{Advanced Multi-Step with Analysis}

\begin{lstlisting}[language=Python, caption=Advanced Multi-Step Example]
def advanced_multi_step_example():
    """Advanced multi-step time evolution with detailed analysis."""
    
    setup = quick_setup("bionetflux.problems.reduced_ooc_problem", validate=True)
    time_stepper = TimeStepper(setup, verbose=True)
    
    # Initialize
    initial_solution, initial_bulk_data = time_stepper.initialize_solution()
    
    # Multi-step advancement
    dt = setup.global_discretization.dt
    n_steps = 20
    
    print(f"Advancing {n_steps} steps with dt={dt}")
    
    results = time_stepper.advance_multiple_steps(
        initial_solution=initial_solution,
        initial_bulk_data=initial_bulk_data,
        start_time=0.0,
        dt=dt,
        n_steps=n_steps,
        stop_on_failure=False  # Continue even if some steps fail
    )
    
    # Detailed analysis
    successful_results = [r for r in results if r.converged]
    failed_results = [r for r in results if not r.converged]
    
    print(f"\n=== ANALYSIS ===")
    print(f"Total steps: {len(results)}")
    print(f"Successful: {len(successful_results)} ({len(successful_results)/len(results)*100:.1f}%)")
    print(f"Failed: {len(failed_results)}")
    
    if successful_results:
        # Newton iteration statistics
        iterations = [r.iterations for r in successful_results]
        computation_times = [r.computation_time for r in successful_results]
        residual_norms = [r.final_residual_norm for r in successful_results]
        
        print(f"\nNewton Iteration Statistics:")
        print(f"  Average iterations: {np.mean(iterations):.1f}")
        print(f"  Max iterations: {max(iterations)}")
        print(f"  Min iterations: {min(iterations)}")
        
        print(f"\nTiming Statistics:")
        print(f"  Total computation time: {sum(computation_times):.4f}s")
        print(f"  Average time per step: {np.mean(computation_times):.4f}s")
        print(f"  Max time per step: {max(computation_times):.4f}s")
        
        print(f"\nConvergence Statistics:")
        print(f"  Average final residual: {np.mean(residual_norms):.2e}")
        print(f"  Max final residual: {max(residual_norms):.2e}")
        print(f"  Min final residual: {min(residual_norms):.2e}")
        
        # Convergence history analysis
        convergence_rates = []
        for result in successful_results:
            if result.residual_history and len(result.residual_history) > 1:
                initial_res = result.residual_history[0]
                final_res = result.residual_history[-1]
                if initial_res > 0:
                    rate = np.log(final_res / initial_res) / result.iterations
                    convergence_rates.append(rate)
        
        if convergence_rates:
            print(f"\nConvergence Rate Statistics:")
            print(f"  Average convergence rate: {np.mean(convergence_rates):.2e}")
            print(f"  Convergence rate std: {np.std(convergence_rates):.2e}")
    
    # Per-step detailed output
    print(f"\n=== PER-STEP DETAILS ===")
    for i, result in enumerate(results):
        status = "✓" if result.converged else "✗"
        print(f"Step {i+1:2d}: {status} {result.iterations:2d} its, "
              f"||R||={result.final_residual_norm:.2e}, "
              f"time={result.computation_time:.4f}s")
    
    return results, successful_results, failed_results

# Run advanced example
results, success, failures = advanced_multi_step_example()
\end{lstlisting}

\subsubsection{Adaptive Time Stepping with Monitoring}

\begin{lstlisting}[language=Python, caption=Adaptive Time Stepping Example]
def adaptive_time_stepping_example():
    """Comprehensive adaptive time stepping with monitoring."""
    
    setup = quick_setup("bionetflux.problems.reduced_ooc_problem", validate=True)
    time_stepper = TimeStepper(setup, verbose=True)
    
    # Get adaptive stepper
    adaptive_stepper = time_stepper.get_adaptive_stepper(
        dt_min=1e-6,
        dt_max=0.1,
        safety_factor=0.8
    )
    
    # Initialize
    current_solution, current_bulk_data = adaptive_stepper.initialize_solution()
    
    # Adaptive evolution parameters
    current_time = 0.0
    max_time = 0.5
    dt_initial = setup.global_discretization.dt
    dt_current = dt_initial
    
    # Monitoring arrays
    time_history = [current_time]
    dt_history = []
    newton_iterations = []
    step_count = 0
    max_steps = 100
    
    print(f"Adaptive time stepping: t ∈ [0, {max_time}], initial dt={dt_initial}")
    print(f"dt range: [{adaptive_stepper.dt_min:.2e}, {adaptive_stepper.dt_max:.2e}]")
    
    while current_time < max_time and step_count < max_steps:
        step_count += 1
        print(f"\n--- Adaptive Step {step_count} ---")
        print(f"  Current time: {current_time:.6f}")
        print(f"  Trying dt: {dt_current:.6f}")
        
        # Adaptive time step
        result, dt_next = adaptive_stepper.advance_time_step_adaptive(
            current_solution=current_solution,
            current_bulk_data=current_bulk_data,
            current_time=current_time,
            dt_suggested=dt_current
        )
        
        # Record history
        dt_history.append(dt_current)
        
        if result.converged:
            # Success - update state
            current_time += dt_current
            current_solution = result.updated_solution
            current_bulk_data = result.updated_bulk_data
            
            # Record monitoring data
            time_history.append(current_time)
            newton_iterations.append(result.iterations)
            
            # Display step info
            efficiency = "FAST" if result.iterations <= 3 else "NORMAL" if result.iterations <= 8 else "SLOW"
            print(f"  ✓ Step successful ({efficiency})")
            print(f"    Newton iterations: {result.iterations}")
            print(f"    Final residual: {result.final_residual_norm:.2e}")
            print(f"    dt: {dt_current:.6f} → {dt_next:.6f}")
            
            # Update dt for next step
            dt_current = dt_next
            
        else:
            print(f"  ✗ All retries failed")
            print(f"    Final attempt residual: {result.final_residual_norm:.2e}")
            break
    
    # Final analysis
    print(f"\n=== ADAPTIVE STEPPING ANALYSIS ===")
    print(f"Steps completed: {step_count}")
    print(f"Final time: {current_time:.6f}")
    print(f"Time coverage: {current_time/max_time*100:.1f}%")
    
    if dt_history:
        print(f"\nTime Step Statistics:")
        print(f"  Initial dt: {dt_initial:.6f}")
        print(f"  Final dt: {dt_current:.6f}")
        print(f"  Min dt used: {min(dt_history):.6f}")
        print(f"  Max dt used: {max(dt_history):.6f}")
        print(f"  Average dt: {np.mean(dt_history):.6f}")
        print(f"  dt std deviation: {np.std(dt_history):.6f}")
        
        # dt adaptation frequency
        dt_increases = sum(1 for i in range(1, len(dt_history)) 
                          if dt_history[i] > dt_history[i-1])
        dt_decreases = sum(1 for i in range(1, len(dt_history)) 
                          if dt_history[i] < dt_history[i-1])
        dt_unchanged = len(dt_history) - 1 - dt_increases - dt_decreases
        
        print(f"\ndt Adaptation Statistics:")
        print(f"  Increases: {dt_increases}")
        print(f"  Decreases: {dt_decreases}")
        print(f"  Unchanged: {dt_unchanged}")
    
    if newton_iterations:
        print(f"\nNewton Iteration Statistics:")
        print(f"  Average: {np.mean(newton_iterations):.1f}")
        print(f"  Min: {min(newton_iterations)}")
        print(f"  Max: {max(newton_iterations)}")
        print(f"  Std: {np.std(newton_iterations):.1f}")
    
    return adaptive_stepper, time_history, dt_history, newton_iterations

# Run adaptive example
adaptive_stepper, times, dts, iters = adaptive_time_stepping_example()
\end{lstlisting}

\subsection{Integration with BioNetFlux Components}

The TimeStepper module integrates seamlessly with other BioNetFlux components:

\begin{itemize}
    \item \textbf{SolverSetup}: Primary interface for accessing all framework components
    \item \textbf{NewtonSolver}: BioNetFlux-specific Newton iteration with global assembler integration
    \item \textbf{BulkDataManager}: Efficient bulk data management and forcing term computation
    \item \textbf{GlobalAssembler}: System assembly and bulk solution recovery
    \item \textbf{StaticCondensation}: Element-level static condensation implementations
    \item \textbf{TimeStepResult}: Comprehensive result data structure
\end{itemize}

\subsection{Method Summary Table}
\label{subsec:time_stepper_method_summary}

\begin{longtable}{|p{5.5cm}|p{4cm}|p{4.5cm}|}
\hline
\textbf{Method} & \textbf{Returns} & \textbf{Purpose} \\
\hline
\endhead

\texttt{\_\_init\_\_} & \texttt{None} & Initialize time stepper with setup and Newton solver \\
\hline

\texttt{initialize\_solution} & \texttt{Tuple} & Initialize solution and bulk data at t=0 \\
\hline

\texttt{advance\_time\_step} & \texttt{TimeStepResult} & Advance solution by one time step \\
\hline

\texttt{advance\_multiple\_steps} & \texttt{List[TimeStepResult]} & Advance multiple time steps in sequence \\
\hline

\texttt{get\_adaptive\_stepper} & \texttt{AdaptiveTimeStepper} & Get adaptive time stepper instance \\
\hline

\texttt{\_create\_failed\_result} & \texttt{TimeStepResult} & Create failed result with error information \\
\hline

\texttt{advance\_time\_step\_adaptive} & \texttt{Tuple} & Adaptive time step with dt control \\
\hline

\end{longtable}

\subsection{Key Features and Design Principles}

\begin{itemize}
    \item \textbf{Complete Encapsulation}: All Newton iteration and bulk data logic encapsulated in clean interface
    \item \textbf{Massive Simplification}: Reduces ~50 lines of complex while loop to single method call
    \item \textbf{Comprehensive Error Handling}: Robust error reporting and recovery at all stages
    \item \textbf{Performance Monitoring}: Detailed timing and convergence information in results
    \item \textbf{Adaptive Capabilities}: Built-in support for automatic time step control
    \item \textbf{Multi-Step Support}: Efficient batch processing of multiple time steps
    \item \textbf{Flexible Integration}: Works with existing Newton solvers and can be extended
    \item \textbf{Verbose Reporting}: Detailed progress information for debugging and monitoring
    \item \textbf{State Management}: Clean separation of current state and updated state
    \item \textbf{Component Caching}: Efficient caching of frequently used framework components
\end{itemize}

This documentation provides an exact reference for the time stepper module, emphasizing its role as the central component for time advancement in BioNetFlux simulations and its dramatic simplification of the time evolution process.

\begin{todobox}
	\begin{itemize}
		\item Extend to other time-stepping methods
		\item Add Picard method to solve non linear system
		\item Change the default verbose status to \tt{False}
	\item Make the \tt{dt} in \tt{advance\_time\_step} optional for use with uniform time-stepping
	\end{itemize}
\end{todobox}

% End of time stepper module detailed API documentation
